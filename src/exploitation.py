from qlearning_de import differential_evolution_qlearning
from config import *
import numpy as np


def exploitation(q_file = None):
    print("\n" + "=" * 60)
    all_results = []
    for func_name in SELECTED_FUNCTIONS:
        sys.stdout = Logger(f"logs/exploitation___{func_name}.txt")
        print(f"USING trained Q-table | Function: {func_name}")
        func = getattr(functions, func_name)
        optimum = OPTIMUM_VALUES.get(func_name, None)

        best_fitness_values = []
        success_rates = []

        try:
            Q_loaded = np.load(q_file)
            print(f"Loaded Q-table from file: {q_file}")
        except FileNotFoundError:
            print(f"File {q_file} not found. Using an empty Q-table.")
            Q_loaded = np.zeros_like(Q_global)

        # Reset visited states and counters
        visited_states.clear()
        state_visit_counts.fill(0)

        for run in range(EXPLOITATION_RUNS):
            print(f"\n--- Exploitation {run + 1}/{EXPLOITATION_RUNS} ---")

            # Initialize Q_global with the loaded Q before each run
            Q_global[:] = Q_loaded

            best_fitness, success_rate = differential_evolution_qlearning(func, func_name, Q_global, config=EXPLOITATION_CONFIG, optimum=optimum, caller_name="exploitation.py")

            # Best fitness value
            best_fitness_values.append(best_fitness)
            success_rates.append(success_rate)

        # Compute aggregated metrics
        mean_best_fitness = np.mean(best_fitness_values)
        std_best_fitness = np.std(best_fitness_values)
        mean_success_rate = np.mean(success_rates)

        print(f"\n{func_name} | Final Aggregated Metrics over {EXPLOITATION_RUNS} runs:")
        print(f"Mean best fitness: {mean_best_fitness:.6f}")
        print(f"Standard deviation of best fitness: {std_best_fitness:.6f}")
        print(f"Mean mutation success rate: {mean_success_rate:.4f}")

        all_results[func_name] = {
            "runs": {
                "best_fitness": best_fitness_values,
                "success_rate": success_rates
            },
            "summary": {
                "mean_best_fitness": mean_best_fitness,
                "std_best_fitness": std_best_fitness,
                "mean_success_rate": mean_success_rate
            }
        }

        return all_results